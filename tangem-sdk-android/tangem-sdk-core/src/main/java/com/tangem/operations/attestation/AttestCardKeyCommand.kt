package com.tangem.operations.attestation

import com.squareup.moshi.JsonClass
import com.tangem.common.CompletionResult
import com.tangem.common.apdu.CommandApdu
import com.tangem.common.apdu.Instruction
import com.tangem.common.apdu.ResponseApdu
import com.tangem.common.card.Card
import com.tangem.common.card.FirmwareVersion
import com.tangem.common.core.CardSession
import com.tangem.common.core.CompletionCallback
import com.tangem.common.core.SessionEnvironment
import com.tangem.common.core.TangemError
import com.tangem.common.core.TangemSdkError
import com.tangem.common.extensions.guard
import com.tangem.common.tlv.Tlv
import com.tangem.common.tlv.TlvBuilder
import com.tangem.common.tlv.TlvDecoder
import com.tangem.common.tlv.TlvTag
import com.tangem.crypto.CryptoUtils
import com.tangem.operations.Command
import com.tangem.operations.CommandResponse
import com.tangem.operations.PreflightReadMode

/**
 * Deserialized response from the Tangem card after `AttestCardKeyCommand`.
 * @property cardId Unique Tangem card ID number
 * @property salt Random salt generated by the card
 * @property cardSignature Hashed concatenated Challenge and Salt: SHA256(Challenge | Salt) signed with Card_PrivateKey
 * @property challenge Random challenge generated by host application
 * @property linkedCardsPublicKeys Card's public keys of linked cards if "full" attestationMode was selected. COS v6+.
 */
@JsonClass(generateAdapter = true)
class AttestCardKeyResponse(
    val cardId: String,
    val salt: ByteArray,
    val cardSignature: ByteArray,
    val challenge: ByteArray,
    val linkedCardsPublicKeys: List<ByteArray>,
) : CommandResponse {

    fun verify(cardPublicKey: ByteArray): Boolean {
        var message = challenge + salt
        if (linkedCardsPublicKeys.isNotEmpty()) {
            message += linkedCardsPrefix.toByteArray() + linkedCardsPublicKeys.flatMap { it.toList() }.toByteArray()
        }

        return CryptoUtils.verify(cardPublicKey, message, cardSignature)
    }

    companion object {
        private const val linkedCardsPrefix = "BACKUP_CARDS"
    }
}

/**
 * @property mode Full attestation available only for COS v6+. It can be used to get all public keys of linked cards.
 * @property challenge Optional challenge. If null, it will be created automatically and returned in command response
 */
class AttestCardKeyCommand(
    private val mode: Mode = Mode.Default,
    private var challenge: ByteArray? = null,
) : Command<AttestCardKeyResponse>() {

    override fun preflightReadMode(): PreflightReadMode = PreflightReadMode.ReadCardOnly

    override fun performPreCheck(card: Card): TangemError? {
        if (mode == Mode.Full && card.firmwareVersion < FirmwareVersion.KeysImportAvailable) {
            return TangemSdkError.NotSupportedFirmwareVersion()
        }
        return null
    }

    override fun run(session: CardSession, callback: CompletionCallback<AttestCardKeyResponse>) {
        challenge = challenge ?: CryptoUtils.generateRandomBytes(length = 16)
        val cardPublicKey = session.environment.card?.cardPublicKey.guard {
            callback(CompletionResult.Failure(TangemSdkError.MissingPreflightRead()))
            return
        }

        super.run(session) { result ->
            when (result) {
                is CompletionResult.Success -> {
                    val verified = result.data.verify(cardPublicKey)
                    if (verified) {
                        callback(CompletionResult.Success(result.data))
                    } else {
                        callback(CompletionResult.Failure(TangemSdkError.CardVerificationFailed()))
                    }
                }

                is CompletionResult.Failure -> callback(result)
            }
        }
    }

    override fun serialize(environment: SessionEnvironment): CommandApdu {
        val card = environment.card.guard {
            throw TangemSdkError.MissingPreflightRead()
        }

        val builder = TlvBuilder()
        builder.append(TlvTag.Pin, environment.accessCode.value)
        builder.append(TlvTag.CardId, environment.card?.cardId)
        builder.append(TlvTag.Challenge, challenge)
        if (card.backupStatus?.isActive == true) {
            builder.append(TlvTag.InteractionMode, mode.toRawMode())
        }
        return CommandApdu(Instruction.AttestCardKey, builder.serialize())
    }

    override fun deserialize(environment: SessionEnvironment, apdu: ResponseApdu): AttestCardKeyResponse {
        val tlv = apdu.getTlvData() ?: throw TangemSdkError.DeserializeApduFailed()

        val decoder = TlvDecoder(tlv)
        return AttestCardKeyResponse(
            cardId = decoder.decode(TlvTag.CardId),
            salt = decoder.decode(TlvTag.Salt),
            cardSignature = decoder.decode(TlvTag.CardSignature),
            challenge = challenge!!,
            linkedCardsPublicKeys = decodeLinkedCardsPublicKeys(tlv),
        )
    }

    @Throws
    private fun decodeLinkedCardsPublicKeys(tlvs: List<Tlv>): List<ByteArray> {
        val linkedCardsPublicKeysTlv = tlvs.filter { it.tag == TlvTag.BackupCardPublicKey }
        val linkedCardsPublicKeys = linkedCardsPublicKeysTlv.map { tlv ->
            TlvDecoder(listOf(tlv)).decode<ByteArray>(TlvTag.BackupCardPublicKey)
        }
        return linkedCardsPublicKeys
    }

    enum class Mode {
        Default, Full;
    }

    private fun Mode.toRawMode(): RawMode? {
        return when (this) {
            Mode.Default -> null
            Mode.Full -> RawMode.Full
        }
    }

    enum class RawMode(val value: Byte) {
        Full(0x01),
    }
}
